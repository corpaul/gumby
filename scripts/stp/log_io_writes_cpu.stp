global backtrace;
global ioWriteCounter, filehandles, times; /* doesIO,*/
global totalTime;
global i;
global index;
global filesWritten;
global inLib;

function getPyBacktrace(currentTid)
{
	pyBacktrace = "";
	foreach ([tid, i2-] in backtrace) {
		if(@count(index) < 10 & tid == currentTid)
		{
			str = backtrace[tid, i2];


		/*	if(isinstr(str, "/home/user/python-src/virtualenv-attempt/inst/"))
				str = substr(str, 45, strlen(str)); */

			pyBacktrace = sprintf("%s<-%s", pyBacktrace, str);
			index <<< 1;
		}
		else
		{
			delete index;
			break;
		}
	}
	return pyBacktrace;
}


probe python.function.entry
{
	if(!isinstr(filename, "lib/python"))
	{

		i[tid()] += 1
		//backtrace[tid(), i[tid()]] = sprintf("%s:%d:%s (%d  %d)", filename, lineno, funcname, tid(), i[tid()]);
		//backtrace[tid(), i[tid()]] = sprintf("%s:%d:%s", filename, lineno, funcname);
		backtrace[tid(), i[tid()]] = sprintf("%s:%s", filename, funcname);
		times[tid(), funcname] = task_utime();
	}
	/*doesIO[tid(), i[tid()]] = 0;*/
}

probe python.function.return
{
	if(!isinstr(filename, "lib/python"))
	{
		if(i[tid()] > 0)
		{
			printf("TASK_UTIME: %d\n %s\n", cputime_to_msecs(task_utime()), task_time_string());
			execTime =  task_utime()-times[tid(), funcname];
			bt = getPyBacktrace(tid());
	/*		bt = sprintf("%s:%s", filename, funcname); */
			foreach ([tid, i2] in ioWriteCounter)
			{
				if(tid == tid() && i2 == i[tid()] && ioWriteCounter[tid, i2] > 0)
				{

					printf("%d,WRITE,%s,%s,%d,%s,1\n", gettimeofday_us(), filehandles[tid, filesWritten[tid, i2]], bt, ioWriteCounter[tid(), i2], task_execname(pid2task(pid())) );

				}

			}
			totalTime[bt] <<< execTime

			delete times[tid(), funcname];
			delete ioWriteCounter[tid(), i[tid()]];
			delete backtrace[tid(), i[tid()]];
			i[tid()] -= 1
		}
	}

}

probe syscall.open.return
{
	fd = $return;
	//filehandles[tid(), fd] = sprintf("%s (%d)", user_string($filename), tid());
	filehandles[tid(), fd] = sprintf("%s", user_string($filename));
	filesWritten[tid(), i[tid()]] = fd;
}

probe syscall.write.return {
	if ($return>0) {
		/* doesIO[tid(), i[tid()]] = 1; */
		ioWriteCounter[tid(), i[tid()]] += $return;

	}
}

/*
probe syscall.read.return {
	if ($return>0) {
		ioReadCounter[tid(), i[tid()]] += $return;
	}
}
*/
probe begin {
	printf("\"TIMESTAMP\",\"TYPE\",\"FILE\",\"TRACE\",\"VALUE\",\"PROCESS\",\"CALLS\"\n");
}

probe end, timer.s(60){
	foreach ([funcname] in totalTime)
	{
		printf("%d,CPU,xx,%s,%d,xx,%d\n", gettimeofday_us(), funcname, @avg(totalTime[funcname]), @count(totalTime[funcname]) );
	}
	delete totalTime;
}

/*
probe timer.s(120)
{
	delete output;
}
*/

